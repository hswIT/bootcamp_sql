-- ORDER BY
SELECT * FROM STAFFS
ORDER BY STAFF_NAME;

-- NULL values come first
SELECT * FROM STAFFS
ORDER BY STAFF_EMAIL;

-- DESC by multiple columns
SELECT * FROM STAFFS
ORDER BY GENDER DESC, STAFF_NAME DESC ;

SELECT * FROM STAFFS
ORDER BY EMPLOYMENT_DATE DESC;

-- GROUP BY + HAVING
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU' -- filter data (before group by)
GROUP BY GENDER
HAVING COUNT(1) > 1; -- filter group

-- explanation of the above
-- Step 1: filter data (before group)
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU';

-- testing
SELECT 'HELLO', S.*
FROM STAFFS S
WHERE S.STAFF_NAME LIKE '%LAU';


-- Step 2: 
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU' -- filter data (before group by)
GROUP BY GENDER;

-- Step 3: use HAVING to determine which group should exist
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU' -- filter data (before group by)
GROUP BY GENDER
HAVING COUNT('HELLO') > 1;

-- Example 2: group by + having
SELECT DEPT_CODE, SUM(SALARY) AS SUM_OF_SALARY, MAX(SALARY), AVG(SALARY)
FROM STAFFS
GROUP BY DEPT_CODE
HAVING MAX(SALARY) > 30000; -- which dept having employee whose salary > 30000

-- CASE
SELECT CASE
		WHEN DEPT_CODE = 'IT' THEN 'INFORMATION TECHNOLOGY'
        WHEN DEPT_CODE = 'MK' THEN 'MARKETING'
        WHEN DEPT_CODE = 'HR' THEN 'HUMNA RESOURCES'
			END AS 'DEPT_DESCRIPTION'
		,CASE
		WHEN SALARY > 30000 THEN 'H'
        WHEN SALARY > 20000 THEN 'M'
        ELSE 'S'
			END AS 'SALARY_GROUP'
		, STAFF_NAME, SALARY
FROM STAFFS;

-- DISTINCT (show all possible values)
-- "DISTNICT GENDER, DEPT_CODE" -> DISTINCT 2 COLUMNS
SELECT DISTINCT GENDER, DEPT_CODE
FROM STAFFS;

-- group by two columns
SELECT GENDER, DEPT_CODE, SUM(SALARY), MAX(SALARY)
FROM STAFFS
GROUP BY GENDER, DEPT_CODE; -- one group definition

-- create table ORDERS with datetime
CREATE TABLE ORDERS (
	ID INTEGER,
    ORDER_DATE DATETIME,
    COUPON_CODE VARCHAR(10),
    ORDER_STATUS VARCHAR(1)
);

INSERT INTO ORDERS 
VALUES (1, str_to_date('2023-01-01 00:00:00', '%Y-%m-%d %T'), NULL, 'P');

INSERT INTO ORDERS 
VALUES (2, '2024-12-31 18:06:23', NULL, 'P');

-- LIMIT + GROUP BY
SELECT *
FROM STAFFS
ORDER BY SALARY DESC
LIMIT 2; -- first two rows of the result set after order by

-- JOIN
CREATE TABLE NUMBERS (
	NUMBER1 INTEGER,
    NUMBER2 INTEGER
);

INSERT INTO NUMBERS VALUES (1,10);
INSERT INTO NUMBERS VALUES (2,105);
INSERT INTO NUMBERS VALUES (3,299);

CREATE TABLE NAMES (
	NAME1 VARCHAR(10),
    NAME2 VARCHAR(10),
    NUM INTEGER
);

INSERT INTO NAMES VALUES ('JOHN','PETER', 2);
INSERT INTO NAMES VALUES ('JENNY','SALLY', 1);
INSERT INTO NAMES VALUES ('STEVEN','OSCAR', 4);

-- INNER JOIN (without condition)
-- find out all combinations
-- 9 X 5 (9 = 3 X 3, 5 columns)
SELECT R.* ,N.*
FROM NUMBERS R INNER JOIN NAMES N;

-- INNER JOIN (with condition)
-- 2 X 5
-- join only affect the rows
SELECT R.* ,N.*
FROM NUMBERS R INNER JOIN NAMES N ON R.NUMBER1 = N.NUM;

-- INNER JOIN: DEPARTMENTS + STAFFS 
-- ONE TO MANY: ONE STAFF BELONGS TO ONE DEPT, BUT ONE DEPT MAY HAVE MORE THAN ONE STAFF
CREATE TABLE DEPARTMENTS (
	ID INTEGER,
    DEPT_CODE VARCHAR(2),
    DEPT_DESC VARCHAR(100)
);
INSERT INTO DEPARTMENTS VALUES (1, 'IT', 'INFORMATION TECHNOLOGY');
INSERT INTO DEPARTMENTS VALUES (2, 'HR', 'HUMAN RESOURCES');
INSERT INTO DEPARTMENTS VALUES (3, 'MK', 'MARKETING');

-- INNER JOIN + ORDER BY
SELECT D.DEPT_DESC, S.STAFF_NAME, S.SALARY
FROM DEPARTMENTS D INNER JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
ORDER BY S.DEPT_CODE, S.SALARY DESC;

-- INNER JOIN + GROUP BY
SELECT D.DEPT_CODE, SUM(S.SALARY) AS DEPT_TOTAL_SALARY
FROM DEPARTMENTS D INNER JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE
ORDER BY DEPT_TOTAL_SALARY DESC; -- last step of SQL


-- LEFT JOIN (WITHOUT GROUP)
SELECT D.*, S.*
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE;


-- LEFT JOIN
INSERT INTO DEPARTMENTS VALUES (4, 'CS', 'CUSTOMER SERVICE');
-- CS DEPARTMENT HAS NO STAFF
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE;

-- RIGHT JOIN (same result as the above)
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM STAFFS S RIGHT JOIN DEPARTMENTS D ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE;

-- LEFT JOIN (WITHOUT INTERSECT)
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
WHERE S.ID IS NULL
GROUP BY D.DEPT_CODE;

-- EXISTS/ NOT EXISTS (YOU HAVE TO USE A KEY TO MAP)
-- FIND THE DEPARTMENT WHICH HAS NO STAFF
-- DISADVANTAGE: YOU CANNOT SELECT COLUMN IN TABLE STAFF
SELECT D.*
FROM DEPARTMENTS D
WHERE NOT EXISTS (SELECT 1 FROM STAFFS S WHERE D.DEPT_CODE = S.DEPT_CODE);

SELECT D.*
FROM DEPARTMENTS D
WHERE EXISTS (SELECT 1 FROM STAFFS S WHERE D.DEPT_CODE = S.DEPT_CODE);




----------------------- NOTES -----------------------
-- Visualizing the Execution Order:

-- To better grasp the sequence, here's a step-by-step visualization:

    -- 1) FROM: Access the data source.
    -- 2) WHERE: Apply row-level filters.
    -- 3) GROUP BY: Group the filtered data.
    -- 4) HAVING: Apply group-level filters.
    -- 5) SELECT: Choose the columns and calculations to display.
    -- 6) ORDER BY: Sort the final results (if specified).
    -- 7) LIMIT: Restrict the number of returned rows (if specified). 